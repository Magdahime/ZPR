/**
 * \file
 * \author Magdalena Majkowska
 */

#pragma once

#ifndef LINUX_PRAGMA
#pragma warning(push, 0)
#endif //LINUX_PRAGMA

#include <iostream>
#include <cmath>
#include <vector>

#ifndef LINUX_PRAGMA
#pragma warning(pop)
#endif //LINUX_PRAGMA

#include "Perlin.h"
#include "structs/RgbHsv.h"

namespace zpr
{
    constexpr int DEGREES = 360;
    constexpr int INVALID_COORDS = -1;
    /**
     * \author Magdalena Majkowska
     * 
     * Map class, holding the pixel data of the simulation as a simple 1D array.
     */
    class Map
    {
        size_t width_;
        size_t height_;
        std::vector<unsigned char> pixels_;
        std::vector<float> HSVpixels_;

        Map(const Map &) = delete;
        Map(Map &&) = delete;
        Map &operator=(Map &&) = delete;
        Map &operator=(const Map &) = delete;
        Map() = delete;

    public:
        Map(int width, int height) : width_(width), height_(height)
        {
            pixels_ = std::vector<unsigned char>(width_ * height_ * 4);
            HSVpixels_ = std::vector<float>(width_ * height_ * 4);
        };
        ~Map() = default;
        
        /**
         * Creates map from array generated by Perlin Noise Generator. 
         * In our simulation we use both RGB and HSV map, so it was necessary to
         * implement the converters.  
         * \param perlin object of class Perlin that will generate the noise.
         */
        void generateMapFromPerlin(Perlin &perlin);
        inline int getWidth() { return width_; };
        inline int getHeight() { return height_; };
        /**
        * Gets value of the selected pixel from the RGB version of the map
        * \param x x coordinate on the map
        * \param y y coordinate on the map
        * \param offset Used to acces the certain value of colour 0 - red, 1 - green, 2 - blue
        * \return Value of the pixel
        */
        inline short getPixel(unsigned int x, unsigned int y, unsigned int offset)
        {
            if (x < width_ && y < height_ && offset < 4)
                return pixels_[width_ * y * 4 + x * 4 + offset];
            return INVALID_COORDS;
        };
        /**
        * Gets value of the selected pixel from the HSV version of the map
        * \param x x coordinate on the map
        * \param y y coordinate on the map
        * \param offset Used to acces the certain value of colour 0 - red, 1 - green, 2 - blue
        * \return Value of the pixel
        */
        inline float getPixelH(unsigned int x, unsigned int y, unsigned int offset = 0)
        {
            if (x < width_ && y < height_ && offset < 4)
                return HSVpixels_[width_ * y * 4 + x * 4 + offset];
            return INVALID_COORDS;
        }
        /**
         * Return pointer to underlying array of pixels_ vector
         */
        inline unsigned char *getPixels(){ return pixels_.data(); };
    };
}; // namespace zpr